# -*- coding: utf-8 -*-
"""FuelEconomyScoreModel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OigwDLB2Ak9774ZDBOLUhA30O-6UT8nE
"""

import numpy as np
import pandas as pd
df=pd.read_csv("/content/fuel.csv")
data=pd.DataFrame(df)
print(data)

data.shape

data.info()

"""**DATA PREPROCESSING**"""

columns=[]
for col in data.columns:
  if (data[col].nunique()==0):
    columns.append(col)
columns

data=data.drop(columns=columns,axis=1)
print(data)

columns=[]
for col in data.columns:
  if ((data[col].isna().sum()) > 0):
    columns.append(col)
columns

missing_data=data[columns]
t=(missing_data.isna().sum() / len(data)) * 100
print(t)

columns=[]
for col in missing_data.columns:
  if (((missing_data[col].isna().sum() / len(data)) * 100) > 40):
    columns.append(col)
columns

data=data.drop(columns=columns,axis=1)
print(data)

data.info()

from sklearn.preprocessing import LabelEncoder
label_encoder=LabelEncoder()
columns_to_encode=['make','model','class','drive','transmission','fuel_type','fuel_type_1','my_mpg_data','gasoline_electricity_blended_cd']
print(columns_to_encode)
for column in columns_to_encode:
  data[column]=label_encoder.fit_transform(data[column])
print(data)

Missing_columns= data[["drive","transmission"]]
from sklearn.impute import SimpleImputer
imputer=SimpleImputer(missing_values=np.nan,strategy='mean')
imputer=imputer.fit(Missing_columns[["drive","transmission",]])
imputer

Missing_columns[["drive","transmission"]]=imputer.fit_transform(Missing_columns[["drive","transmission"]])
Missing_columns

data=data.drop(['engine_cylinders','engine_displacement'],axis=1)

data.shape

"""LABEL ENCODING"""

from sklearn.preprocessing import LabelEncoder

columns_to_encode = ['make','model','class','drive','transmission','fuel_type','fuel_type_1','my_mpg_data','gasoline_electricity_blended_cd']

label_encoder = LabelEncoder()


for column in columns_to_encode:
    data[column] = label_encoder.fit_transform(data[column])

print(data)

"""  **SPLITTING**"""

from sklearn.model_selection import train_test_split
x=data.drop(['fuel_economy_score'],axis=1)
y=data['fuel_economy_score']
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

print("Training set shape:", x_train.shape, y_train.shape)
print("Testing set shape:", x_test.shape, y_test.shape)
#print(x_train)
print(x_test)

"""**CLASSIFICATION AND REGRESSION ALGORITHMS**"""

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.neural_network import MLPClassifier
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis

# Define a list of classifiers
classifiers = [
    LogisticRegression(),
    DecisionTreeClassifier(),
    RandomForestClassifier(),
    AdaBoostClassifier(),
    GradientBoostingClassifier(),
    KNeighborsClassifier(),
    SVC(),
    GaussianNB(),
    MLPClassifier(),
    LinearDiscriminantAnalysis(),
    QuadraticDiscriminantAnalysis()
]

# Define performance metrics
metrics = {
    'Accuracy': accuracy_score,
    'Precision': precision_score,
    'Recall': recall_score,
    'F1-Score': f1_score
}



# Iterate over classifiers
for classifier in classifiers:
    classifier_name = classifier.__class__.__name__
    print(f"Evaluating {classifier_name}...")

    # Train the classifier
    classifier.fit(x_train, y_train)

    # Predict on the testing data
    y_pred = classifier.predict(x_test)

    # Evaluate performance metrics
    for metric_name, metric_func in metrics.items():
        if metric_name == 'Precision':
          metric_value = metric_func(y_test, y_pred, average='weighted')
        print(f"{metric_name}: {metric_value:.4f}")

    print("="*50)

